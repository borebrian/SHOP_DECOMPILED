!function(){"use strict";class t{constructor(){this.crc=-1,this.table=(()=>{const t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n}return t})()}append(t){const e=this.table;let n=0|this.crc;for(let s=0,i=0|t.length;s<i;s++)n=n>>>8^e[255&(n^t[s])];this.crc=n}get(){return~this.crc}}const e="Invalid pasword",n=16,s="raw",i={name:"PBKDF2"},a={name:"HMAC"},r="SHA-1",c={name:"AES-CTR"},h=Object.assign({hash:a},i),o=Object.assign({iterations:1e3,hash:{name:r}},i),p=Object.assign({hash:r},a),u=Object.assign({length:n},c),d=["deriveBits"],l=["sign"],g=[8,12,16],y=[16,24,32],w=10,f=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],b=crypto.subtle;class A{constructor(t,e,n){this.password=t,this.signed=e,this.strength=n-1,this.input=e&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const s=async(e=0)=>{if(e+n<=a.length-w){const t=a.subarray(e,e+n),r=await b.decrypt(Object.assign({counter:this.counter},u),this.keys.key,t);return k(this.counter),i.set(new Uint8Array(r),e),s(e+n)}return this.pendingInput=a.subarray(e),this.signed&&(this.input=D(this.input,t)),i};if(this.password){const n=t.subarray(0,g[this.strength]+2);await async function(t,n,s){await m(t,s,n.subarray(0,g[t.strength]),["decrypt"]);const i=n.subarray(g[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error(e)}(this,n,this.password),this.password=null,t=t.subarray(g[this.strength]+2)}let i=new Uint8Array(t.length-w-(t.length-w)%n),a=t;return this.pendingInput.length&&(a=D(this.pendingInput,t),i=I(i,a.length-w-(a.length-w)%n)),s()}async flush(){const t=this.pendingInput,e=this.keys,n=t.subarray(0,t.length-w),s=t.subarray(t.length-w);let i=new Uint8Array(0);if(n.length){const t=await b.decrypt(Object.assign({counter:this.counter},u),e.key,n);i=new Uint8Array(t)}let r=!0;if(this.signed){const t=await b.sign(a,e.authentication,this.input.subarray(0,this.input.length-w)),n=new Uint8Array(t);this.input=null;for(let t=0;t<w;t++)n[t]!=s[t]&&(r=!1)}return{valid:r,data:i}}}class U{constructor(t,e){this.password=t,this.strength=e-1,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const e=async(a=0)=>{if(a+n<=t.length){const r=t.subarray(a,a+n),c=await b.encrypt(Object.assign({counter:this.counter},u),this.keys.key,r);return k(this.counter),i.set(new Uint8Array(c),a+s.length),e(a+n)}return this.pendingInput=t.subarray(a),this.output=D(this.output,i),i};let s=new Uint8Array(0);this.password&&(s=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(g[t.strength]));return await m(t,e,n,["encrypt"]),D(n,t.keys.passwordVerification)}(this,this.password),this.password=null);let i=new Uint8Array(s.length+t.length-t.length%n);return i.set(s,0),this.pendingInput.length&&(t=D(this.pendingInput,t),i=I(i,t.length-t.length%n)),e()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const e=await b.encrypt(Object.assign({counter:this.counter},u),this.keys.key,this.pendingInput);t=new Uint8Array(e),this.output=D(this.output,t)}const e=await b.sign(a,this.keys.authentication,this.output.subarray(g[this.strength]+2));this.output=null;const n=new Uint8Array(e).subarray(0,w);return{data:D(t,n),signature:n}}}async function m(t,e,n,i){t.counter=new Uint8Array(f);const a=(new TextEncoder).encode(e),r=await b.importKey(s,a,h,!1,d),u=await b.deriveBits(Object.assign({salt:n},o),r,8*(2*y[t.strength]+2)),g=new Uint8Array(u);t.keys={key:await b.importKey(s,g.subarray(0,y[t.strength]),c,!0,i),authentication:await b.importKey(s,g.subarray(y[t.strength],2*y[t.strength]),p,!1,l),passwordVerification:g.subarray(2*y[t.strength])}}function k(t){for(let e=0;e<16;e++){if(255!=t[e]){t[e]++;break}t[e]=0}}function D(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function I(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0)}return t}const C="deflate",v="inflate",S="Invalid signature";class j{constructor(e){this.signature=e.inputSignature,this.encrypted=Boolean(e.inputPassword),this.signed=e.inputSigned,this.compressed=e.inputCompressed,this.inflate=e.inputCompressed&&new e.codecConstructor,this.crc32=e.inputSigned&&new t,this.decrypt=this.encrypted&&new A(e.inputPassword,e.inputSigned,e.inputEncryptionStrength)}async append(t){return this.encrypted&&(t=await this.decrypt.append(t)),this.compressed&&t.length&&(t=await this.inflate.append(t)),!this.encrypted&&this.signed&&this.crc32.append(t),t}async flush(){let t,e=new Uint8Array(0);if(this.encrypted){const t=await this.decrypt.flush();if(!t.valid)throw new Error(S);e=t.data}else if(this.signed){const e=new DataView(new Uint8Array(4).buffer);if(t=this.crc32.get(),e.setUint32(0,t),this.signature!=e.getUint32(0,!1))throw new Error(S)}return this.compressed&&(e=await this.inflate.append(e)||new Uint8Array(0),await this.inflate.flush()),{data:e,signature:t}}}class E{constructor(e){this.encrypted=e.outputEncrypted,this.signed=e.outputSigned,this.compressed=e.outputCompressed,this.deflate=e.outputCompressed&&new e.codecConstructor({level:e.level||5}),this.crc32=e.outputSigned&&new t,this.encrypt=this.encrypted&&new U(e.outputPassword,e.outputEncryptionStrength)}async append(t){let e=t;return this.compressed&&t.length&&(e=await this.deflate.append(t)),this.encrypted?e=await this.encrypt.append(e):this.signed&&this.crc32.append(t),e}async flush(){let t,e=new Uint8Array(0);if(this.compressed&&(e=await this.deflate.flush()||new Uint8Array(0)),this.encrypted){e=await this.encrypt.append(e);const n=await this.encrypt.flush();t=n.signature;const s=new Uint8Array(e.length+n.data.length);s.set(e,0),s.set(n.data,e.length),e=s}else this.signed&&(t=this.crc32.get());return{data:e,signature:t}}}const O={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;self.initCodec&&self.initCodec(),e.codecType.startsWith(C)?e.codecConstructor=self.Deflate:e.codecType.startsWith(v)&&(e.codecConstructor=self.Inflate),T=function(t){return t.codecType.startsWith(C)?new E(t):t.codecType.startsWith(v)?new j(t):void 0}(e)},append:async t=>({data:await T.append(t.data)}),flush:()=>T.flush()};let T;addEventListener("message",(async t=>{const e=t.data,n=e.type,s=O[n];if(s)try{const t=await s(e)||{};if(t.type=n,t.data)try{postMessage(t,[t.data.buffer])}catch(e){postMessage(t)}else postMessage(t)}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}})}}));const M="function";function V(t,e){return class{constructor(n){const s=t=>{if(this.pendingData){const e=this.pendingData;this.pendingData=new Uint8Array(e.length+t.length),this.pendingData.set(e,0),this.pendingData.set(t,e.length)}else this.pendingData=new Uint8Array(t)};if(this.codec=new t(Object.assign({},e,n)),typeof this.codec.onData==M)this.codec.onData=s;else{if(typeof this.codec.on!=M)throw new Error("Cannot register the callback function");this.codec.on("data",s)}}async append(t){return this.codec.push(t),n(this)}async flush(){return this.codec.push(new Uint8Array(0),!0),n(this)}};function n(t){if(t.pendingData){const e=t.pendingData;return t.pendingData=null,e}return new Uint8Array(0)}}self.initCodec=()=>{const{Deflate:t,Inflate:e}=((t,e={})=>({Deflate:V(t.Deflate,e.deflate),Inflate:V(t.Inflate,e.inflate)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}});self.Deflate=t,self.Inflate=e}}();
